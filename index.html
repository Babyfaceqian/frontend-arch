<html>

<head>
    <meta charset="utf-8" />
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <style>
        .links line {
            stroke: #999;
            stroke-opacity: 0.6;
        }

        .nodes circle {
            stroke: #fff;
            stroke-width: 1.5px;
        }
    </style>
</head>

<body>
    <svg width="960" height="600"></svg>
    <script>
        (function () {
            var svg = d3.select('svg'),
                width = +svg.attr('width'),
                height = +svg.attr('height');
            var center_x = width / 2;
            var center_y = height / 2;
            //d3 code goes here 
            var nodes_data = [
                { "name": "Travis", "sex": "M" },
                { "name": "Rake", "sex": "M" },
                { "name": "Diana", "sex": "F" },
                { "name": "Rachel", "sex": "F" },
                { "name": "Shawn", "sex": "M" },
                { "name": "Emerald", "sex": "F" }
            ];

            var simulation = d3.forceSimulation()
                .nodes(nodes_data);

            // set strength
            var manyBody = d3.forceManyBody()
                .strength(-100)
            // .distanceMax(100)
            // .distanceMin(10)

            var force_collide = d3.forceCollide()
                .radius(20);
            var force_center = d3.forceCenter(center_x, center_y);
            // apply the force to simulation
            simulation.force('charge_force', manyBody)
                .force('center_force', force_center)
                .force('collide_force', force_collide)
            // change color according to attributes
            function circleColor(d) {
                if (d.sex === 'M') {
                    return 'blue';
                } else if (d.sex === 'F') {
                    return 'pink'
                }
            }

            function linkColor(d) {
                if (d.type === 'A') {
                    return 'yellow';
                } else if (d.type === 'B') {
                    return 'green';
                }
            }
            var radius = 15;
            var node = svg.append('g')
                .attr('class', 'nodes')
                .selectAll('circle')
                .data(nodes_data)
                .enter()
                .append('circle')
                .attr('r', radius)
                .attr('fill', circleColor)
            //custom force to put stuff in a box 
            // function box_force() {
            //     for (var i = 0, n = nodes_data.length; i < n; ++i) {
            //         curr_node = nodes_data[i];
            //         curr_node.x = Math.max(radius, Math.min(width - radius, curr_node.x));
            //         curr_node.y = Math.max(radius, Math.min(height - radius, curr_node.y));
            //     }
            // }

            function tickActions() {
                // node.attr('cx', function (d) {
                //     return d.x;
                // })
                //     .attr('cy', function (d) {
                //         return d.y
                //     });
                //constrains the nodes to be within a boxï¼›the other way is apply a custom force.
                node.attr("cx", function (d) { return d.x = Math.max(radius, Math.min(width - radius, d.x)); })
                    .attr("cy", function (d) { return d.y = Math.max(radius, Math.min(height - radius, d.y)); });

                link.attr('x1', function (d) {
                    return d.source.x
                })
                    .attr('y1', function (d) {
                        return d.source.y
                    })
                    .attr('x2', function (d) {
                        return d.target.x
                    })
                    .attr('y2', function (d) {
                        return d.target.y
                    })

                //adds 1 to the center position
                // center_x += 1;
                // center_y += 1;

                //updates the center position
                // force_center.x(center_x);
                // force_center.y(center_y);
            }
            simulation.on('tick', tickActions);
            //Create links data 
            var links_data = [
                { "source": "Travis", "target": "Rake", "type": "A" },
                { "source": "Diana", "target": "Rake", "type": "B" },
                { "source": "Diana", "target": "Rachel", "type": "A" },
                { "source": "Rachel", "target": "Rake", "type": "B" },
                { "source": "Rachel", "target": "Shawn", "type": "A" },
                { "source": "Emerald", "target": "Rachel", "type": "A" }
            ];
            var link_force = d3.forceLink(links_data)
                .id(function (d) {
                    return d.name;
                })
                .distance(200)
                .strength(0); // 0 - 1
            simulation.force('links', link_force)

            var link = svg.append('g')
                .attr('class', 'links')
                .selectAll('line')
                .data(links_data)
                .enter()
                .append('line')
                .attr('stroke-width', 2)
                .style('stroke', linkColor);
            //create drag handler with d3.drag()
            //only interested in "drag" event listener, not "start" or "end"        
            // var drag_handler = d3.drag()
            //     .on("drag", function (d) {
            //         d3.select(this)
            //             .attr("cx", d.x = d3.event.x)
            //             .attr("cy", d.y = d3.event.y);
            //     });
            var drag_handler = d3.drag()
                .on('start', function (d) {
                    if (!d3.event.active) simulation.alphaTarget(0.3).restart();
                    d.fx = d.x;
                    d.fy = d.y;
                })
                .on('drag', function (d) {
                    d.fx = d3.event.x;
                    d.fy = d3.event.y;

                })
                .on('end', function (d) {
                    if (!d3.event.active) simulation.alphaTarget(0).restart();
                    d.fx = null;
                    d.fy = null;
                })
            drag_handler(node);

            // apply force on X direction
            var force_X = d3.forceX(400)
                .strength(0.2);
            simulation.force('force_x', force_X);

            //make sure you can't drag the circle outside the box
            // function drag_drag(d) {
            //     d.fx = Math.max(radius, Math.min(width - radius, d3.event.x));
            //     d.fy = Math.max(radius, Math.min(height - radius, d3.event.y));
            // }
        })()
    </script>
</body>

</html>